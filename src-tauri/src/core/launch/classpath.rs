// ─── Classpath Builder ───
// Constructs the dynamic classpath string for launching Minecraft.

use std::path::{Path, PathBuf};

use tracing::debug;

use crate::core::error::{LauncherError, LauncherResult};
use crate::core::instance::{Instance, LoaderType};
use crate::core::maven::MavenArtifact;

/// Builds the full classpath string for launching the game.
///
/// Includes:
/// - `client.jar`
/// - All vanilla libraries
/// - All loader libraries
///
/// Uses `;` on Windows, `:` on Linux/macOS.
pub fn build_classpath(
    instance: &Instance,
    libs_dir: &Path,
    extra_lib_coords: &[String],
) -> LauncherResult<String> {
    let separator = get_classpath_separator();
    let mut entries: Vec<String> = Vec::new();

    // 1. All declared libraries (Vanilla + loader)
    for coord in extra_lib_coords {
        let trimmed = coord.trim();
        if trimmed.is_empty() {
            continue;
        }

        if let Some(entry) = resolve_library_entry(instance, libs_dir, trimmed) {
            entries.push(entry);
        } else {
            debug!("Library not found on disk (skipping): {}", trimmed);
        }
    }

    // 1.1 Fallback: include every local JAR generated by installer-based loaders.
    // Forge/NeoForge installers can materialize additional launch-critical artifacts
    // under instance-local repositories that are not always declared in metadata.
    for discovered_jar in collect_local_library_jars(instance) {
        entries.push(safe_path_str(&discovered_jar));
    }

    // 1.2 Loader/vanilla version JARs generated under `minecraft/versions`.
    // Forge/NeoForge bootstrap classes are provided by these jars, not by Maven libs.
    for version_jar in collect_required_version_jars(instance) {
        entries.push(safe_path_str(&version_jar));
    }

    // 2. Minecraft base client JAR
    let client_jar = instance.path.join("client.jar");
    if client_jar.exists() {
        entries.push(safe_path_str(&client_jar));
    }

    if entries.is_empty() {
        return Err(LauncherError::Other(
            "Classpath is empty — no libraries or client.jar found".into(),
        ));
    }

    entries.retain(|entry| !entry.trim().is_empty());
    dedup_preserving_order(&mut entries);
    if entries.is_empty() {
        return Err(LauncherError::Other(
            "Classpath is empty after filtering invalid entries".into(),
        ));
    }

    Ok(entries.join(separator))
}

/// Platform-specific Java classpath separator.
pub fn get_classpath_separator() -> &'static str {
    if cfg!(target_os = "windows") {
        ";"
    } else {
        ":"
    }
}

fn resolve_library_entry(instance: &Instance, libs_dir: &Path, raw: &str) -> Option<String> {
    let direct_path = Path::new(raw);

    // Absolute path as-is.
    if direct_path.exists() {
        return Some(safe_path_str(direct_path));
    }

    // Relative path candidates (for loader metadata that references local jars).
    let relative_candidates = [
        instance.path.join(raw),
        instance.game_dir().join(raw),
        libs_dir.join(raw),
        instance.game_dir().join("libraries").join(raw),
    ];
    for candidate in relative_candidates {
        if candidate.exists() {
            return Some(safe_path_str(&candidate));
        }
    }

    // Maven coordinate candidates in global and instance-local repositories.
    let artifact = MavenArtifact::parse(raw).ok()?;
    let repo_candidates = [
        libs_dir.join(artifact.local_path()),
        instance.path.join("libraries").join(artifact.local_path()),
        instance
            .game_dir()
            .join("libraries")
            .join(artifact.local_path()),
    ];
    for candidate in repo_candidates {
        if candidate.exists() {
            return Some(safe_path_str(&candidate));
        }
    }

    None
}

fn collect_local_library_jars(instance: &Instance) -> Vec<PathBuf> {
    let mut jars = Vec::new();
    let mut stack = vec![
        instance.path.join("libraries"),
        instance.game_dir().join("libraries"),
    ];

    while let Some(dir) = stack.pop() {
        if !dir.exists() {
            continue;
        }

        let read_dir = match std::fs::read_dir(&dir) {
            Ok(read_dir) => read_dir,
            Err(_) => continue,
        };

        for entry in read_dir.flatten() {
            let path = entry.path();
            if path.is_dir() {
                stack.push(path);
                continue;
            }
            if path
                .extension()
                .and_then(|ext| ext.to_str())
                .is_some_and(|ext| ext.eq_ignore_ascii_case("jar"))
            {
                jars.push(path);
            }
        }
    }

    jars
}

fn collect_required_version_jars(instance: &Instance) -> Vec<PathBuf> {
    let versions_dir = instance.game_dir().join("versions");
    let mut ids = vec![instance.minecraft_version.clone()];

    if let Some(loader_version) = &instance.loader_version {
        match instance.loader {
            LoaderType::Forge => {
                ids.push(format!("{}-{}", instance.minecraft_version, loader_version))
            }
            LoaderType::NeoForge => {
                ids.push(format!("{}-{}", instance.minecraft_version, loader_version));
                ids.push(loader_version.clone());
            }
            _ => {}
        }
    }

    let mut jars = Vec::new();
    for version_id in ids {
        let jar = versions_dir
            .join(&version_id)
            .join(format!("{}.jar", version_id));
        if jar.exists() {
            jars.push(jar);
        }
    }

    jars
}

fn dedup_preserving_order(entries: &mut Vec<String>) {
    let mut seen = std::collections::HashSet::new();
    entries.retain(|entry| seen.insert(entry.clone()));
}

/// Extract native libraries from JARs that contain `.dll`, `.so`, or `.dylib`.
///
/// Creates a temporary `natives/` directory inside the instance.
pub async fn extract_natives(
    instance: &Instance,
    libs_dir: &Path,
    native_coords: &[String],
) -> LauncherResult<PathBuf> {
    let natives_dir = instance.natives_dir();

    // Clean previous session
    if natives_dir.exists() {
        let _ = tokio::fs::remove_dir_all(&natives_dir).await;
    }
    tokio::fs::create_dir_all(&natives_dir)
        .await
        .map_err(|e| LauncherError::Io {
            path: natives_dir.clone(),
            source: e,
        })?;

    for coord in native_coords {
        let artifact = match MavenArtifact::parse(coord) {
            Ok(a) => a,
            Err(_) => continue,
        };
        let jar_path = libs_dir.join(artifact.local_path());
        if !jar_path.exists() {
            continue;
        }

        // Extract .dll/.so/.dylib from the JAR
        let jar_bytes = tokio::fs::read(&jar_path)
            .await
            .map_err(|e| LauncherError::Io {
                path: jar_path.clone(),
                source: e,
            })?;
        let cursor = std::io::Cursor::new(jar_bytes);
        let mut archive = match zip::ZipArchive::new(cursor) {
            Ok(a) => a,
            Err(e) => {
                tracing::warn!("Cannot open native JAR {:?}: {}", jar_path, e);
                continue;
            }
        };

        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            let name = file.name().to_string();

            let is_native = name.ends_with(".dll")
                || name.ends_with(".so")
                || name.ends_with(".dylib")
                || name.ends_with(".jnilib");

            if is_native && !name.contains('/') {
                let dest = natives_dir.join(&name);
                let mut out = std::fs::File::create(&dest).map_err(|e| LauncherError::Io {
                    path: dest.clone(),
                    source: e,
                })?;
                std::io::copy(&mut file, &mut out).map_err(|e| LauncherError::Io {
                    path: dest.clone(),
                    source: e,
                })?;
                debug!("Extracted native: {}", name);
            }
        }
    }

    Ok(natives_dir)
}

/// Clean up the temporary natives directory after the game exits.
pub async fn cleanup_natives(instance: &Instance) {
    let natives_dir = instance.natives_dir();
    if natives_dir.exists() {
        let _ = tokio::fs::remove_dir_all(&natives_dir).await;
    }
}

/// Convert path to string, using `\\?\` prefix on Windows for long path support.
pub fn safe_path_str(path: &Path) -> String {
    let resolved = std::fs::canonicalize(path).unwrap_or_else(|_| path.to_path_buf());
    let text = resolved.to_string_lossy().to_string();

    #[cfg(target_os = "windows")]
    {
        // Java classpath handling can fail for Windows extended-length paths
        // (e.g. `\\?\C:\...`) and report `ClassNotFoundException` even when
        // jars exist. Strip the prefix before building launch arguments.
        if let Some(stripped) = text.strip_prefix(r"\\?\") {
            return stripped.to_string();
        }
    }

    text
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::instance::{Instance, LoaderType};

    fn test_instance(base_dir: &Path) -> Instance {
        let mut instance = Instance::new(
            "test".into(),
            "1.21.1".into(),
            LoaderType::Vanilla,
            None,
            2048,
            base_dir,
        );
        instance.path = base_dir.to_path_buf();
        instance
    }

    #[test]
    fn build_classpath_rejects_empty_entries() {
        let temp =
            std::env::temp_dir().join(format!("classpath-test-empty-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&temp);
        std::fs::create_dir_all(&temp).unwrap();
        let instance = test_instance(&temp);
        let libs_dir = temp.join("libraries");
        std::fs::create_dir_all(&libs_dir).unwrap();

        let err = build_classpath(&instance, &libs_dir, &["   ".into()]).unwrap_err();
        assert!(err.to_string().contains("Classpath is empty"));

        let _ = std::fs::remove_dir_all(&temp);
    }

    #[test]
    fn build_classpath_resolves_instance_local_libraries_for_installer_loaders() {
        let temp =
            std::env::temp_dir().join(format!("classpath-test-local-libs-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&temp);
        let instance_dir = temp.join("instance");
        let game_libs = instance_dir.join("minecraft").join("libraries");
        std::fs::create_dir_all(&game_libs).unwrap();
        std::fs::write(instance_dir.join("client.jar"), b"client").unwrap();

        let coord = "net.minecraftforge:bootstrap:2.1.7";
        let artifact = MavenArtifact::parse(coord).unwrap();
        let local_jar = game_libs.join(artifact.local_path());
        std::fs::create_dir_all(local_jar.parent().unwrap()).unwrap();
        std::fs::write(&local_jar, b"bootstrap").unwrap();

        let instance = test_instance(&instance_dir);
        let classpath =
            build_classpath(&instance, &temp.join("libraries"), &[coord.into()]).unwrap();

        assert!(classpath.contains("bootstrap-2.1.7.jar"));
        assert!(classpath.contains("client.jar"));

        let _ = std::fs::remove_dir_all(&temp);
    }

    #[test]
    fn build_classpath_collects_discovered_local_jars_even_without_declared_coordinate() {
        let temp = std::env::temp_dir().join(format!(
            "classpath-test-discovered-local-jars-{}",
            std::process::id()
        ));
        let _ = std::fs::remove_dir_all(&temp);
        let instance_dir = temp.join("instance");
        let local_repo = instance_dir.join("libraries").join("custom");
        std::fs::create_dir_all(&local_repo).unwrap();
        std::fs::write(instance_dir.join("client.jar"), b"client").unwrap();
        std::fs::write(local_repo.join("installer-generated.jar"), b"local").unwrap();

        let instance = test_instance(&instance_dir);
        let classpath = build_classpath(&instance, &temp.join("libraries"), &[]).unwrap();

        assert!(classpath.contains("installer-generated.jar"));

        let _ = std::fs::remove_dir_all(&temp);
    }
    #[test]
    fn build_classpath_accepts_direct_library_paths() {
        let temp =
            std::env::temp_dir().join(format!("classpath-test-direct-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&temp);
        std::fs::create_dir_all(&temp).unwrap();
        let instance_dir = temp.join("instance");
        std::fs::create_dir_all(&instance_dir).unwrap();
        std::fs::write(instance_dir.join("client.jar"), b"client").unwrap();
        let instance = test_instance(&instance_dir);

        let external_jar = temp.join("external-lib.jar");
        std::fs::write(&external_jar, b"lib").unwrap();

        let classpath = build_classpath(
            &instance,
            &temp.join("libraries"),
            &[external_jar.to_string_lossy().to_string()],
        )
        .unwrap();

        assert!(classpath.contains("external-lib.jar"));
        assert!(classpath.contains("client.jar"));

        let _ = std::fs::remove_dir_all(&temp);
    }

    #[test]
    fn build_classpath_includes_forge_and_vanilla_version_jars() {
        let temp = std::env::temp_dir().join(format!(
            "classpath-test-version-jars-{}",
            std::process::id()
        ));
        let _ = std::fs::remove_dir_all(&temp);
        let instance_dir = temp.join("instance");
        std::fs::create_dir_all(&instance_dir).unwrap();
        std::fs::write(instance_dir.join("client.jar"), b"client").unwrap();

        let mut instance = test_instance(&instance_dir);
        instance.loader = LoaderType::Forge;
        instance.loader_version = Some("47.2.0".into());
        instance.minecraft_version = "1.20.1".into();

        let vanilla_jar = instance
            .game_dir()
            .join("versions")
            .join("1.20.1")
            .join("1.20.1.jar");
        let forge_jar = instance
            .game_dir()
            .join("versions")
            .join("1.20.1-47.2.0")
            .join("1.20.1-47.2.0.jar");

        std::fs::create_dir_all(vanilla_jar.parent().unwrap()).unwrap();
        std::fs::create_dir_all(forge_jar.parent().unwrap()).unwrap();
        std::fs::write(&vanilla_jar, b"vanilla").unwrap();
        std::fs::write(&forge_jar, b"forge").unwrap();

        let classpath = build_classpath(&instance, &temp.join("libraries"), &[]).unwrap();

        assert!(classpath.contains("1.20.1/1.20.1.jar"));
        assert!(classpath.contains("1.20.1-47.2.0/1.20.1-47.2.0.jar"));

        let _ = std::fs::remove_dir_all(&temp);
    }
}
